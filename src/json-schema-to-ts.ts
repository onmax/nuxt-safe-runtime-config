/**
 * Converts a JSON Schema to a TypeScript type string.
 * Handles common JSON Schema patterns used by Zod, Valibot, and ArkType.
 */
export function jsonSchemaToTs(schema: Record<string, unknown>, indent = 0): string {
  const spaces = '  '.repeat(indent)

  // Handle $ref (not supported, return unknown)
  if ('$ref' in schema) {
    return 'unknown'
  }

  // Handle anyOf/oneOf (union types)
  if ('anyOf' in schema && Array.isArray(schema.anyOf)) {
    const types = schema.anyOf.map((s: Record<string, unknown>) => jsonSchemaToTs(s, indent))
    return types.join(' | ')
  }
  if ('oneOf' in schema && Array.isArray(schema.oneOf)) {
    const types = schema.oneOf.map((s: Record<string, unknown>) => jsonSchemaToTs(s, indent))
    return types.join(' | ')
  }

  // Handle allOf (intersection types)
  if ('allOf' in schema && Array.isArray(schema.allOf)) {
    const types = schema.allOf.map((s: Record<string, unknown>) => jsonSchemaToTs(s, indent))
    return types.join(' & ')
  }

  // Handle const
  if ('const' in schema) {
    return JSON.stringify(schema.const)
  }

  // Handle enum
  if ('enum' in schema && Array.isArray(schema.enum)) {
    return schema.enum.map((v: unknown) => JSON.stringify(v)).join(' | ')
  }

  // Handle type
  const type = schema.type

  if (type === 'string') {
    return 'string'
  }

  if (type === 'number' || type === 'integer') {
    return 'number'
  }

  if (type === 'boolean') {
    return 'boolean'
  }

  if (type === 'null') {
    return 'null'
  }

  if (type === 'array') {
    const items = schema.items as Record<string, unknown> | undefined
    if (items) {
      return `${jsonSchemaToTs(items, indent)}[]`
    }
    return 'unknown[]'
  }

  if (type === 'object' || 'properties' in schema) {
    const properties = schema.properties as Record<string, Record<string, unknown>> | undefined
    const required = (schema.required as string[]) || []
    const additionalProperties = schema.additionalProperties

    if (!properties || Object.keys(properties).length === 0) {
      if (additionalProperties === false) {
        return 'Record<string, never>'
      }
      if (typeof additionalProperties === 'object') {
        return `Record<string, ${jsonSchemaToTs(additionalProperties as Record<string, unknown>, indent)}>`
      }
      return 'Record<string, unknown>'
    }

    const lines: string[] = ['{']
    const propIndent = '  '.repeat(indent + 1)

    for (const [key, propSchema] of Object.entries(properties)) {
      const isRequired = required.includes(key)
      const optional = isRequired ? '' : '?'
      const safeKey = /^[\w$]+$/.test(key) && !/^\d/.test(key) ? key : JSON.stringify(key)
      const propType = jsonSchemaToTs(propSchema, indent + 1)
      lines.push(`${propIndent}${safeKey}${optional}: ${propType}`)
    }

    lines.push(`${spaces}}`)
    return lines.join('\n')
  }

  // Handle multiple types (e.g., ["string", "null"])
  if (Array.isArray(type)) {
    const types = type.map((t: string) => {
      switch (t) {
        case 'null': return 'null'
        case 'string': return 'string'
        case 'number':
        case 'integer': return 'number'
        case 'boolean': return 'boolean'
        case 'array': return 'unknown[]'
        case 'object': return 'Record<string, unknown>'
        default: return 'unknown'
      }
    })
    return types.join(' | ')
  }

  // Fallback
  return 'unknown'
}

/**
 * Generates a complete TypeScript declaration file content for the composable.
 */
export function generateTypeDeclaration(schema: Record<string, unknown>): string {
  const tsType = jsonSchemaToTs(schema)

  return `// Auto-generated by nuxt-safe-runtime-config
// Do not edit manually

export type SafeRuntimeConfig = ${tsType}

declare module '#imports' {
  export function useSafeRuntimeConfig(): SafeRuntimeConfig
}

declare module '#app' {
  export function useSafeRuntimeConfig(): SafeRuntimeConfig
}

export {}
`
}
